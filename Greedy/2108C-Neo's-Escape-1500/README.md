# CF 2018C - Neo's Escape

> 原题链接：[Codeforces 2018C](https://codeforces.com/contest/2108/problem/C)

## 题目简述

有 n 个按钮排成一行，每个按钮有权重 a_i。

Neo 可以无限次执行两种操作：

- 创建克隆：在某个按钮前放置一个新克隆。
- 移动克隆：让已有克隆左移或右移一个位置。

克隆一旦到达未被按过的按钮前，会立即按下它（每个按钮只能按一次）

要求按下的按钮权重序列非递增（即 b₁ ≥ b₂ ≥ ... ≥ bₙ）。

求最少需要创建多少个克隆才能完成任务。

Input： 多测试用例，每个用例给出 n 和 a₁, a₂, ..., aₙ。

Output：最少克隆数。

---

## 解题思路

第一思路考虑 类dsu，对于重复元素，我应该向左向右渗透，尽可能将附近的元素都吃掉。

    优化：实际对于重复元素，可以开局就将 **重复连续元素** 处理为单值元素（对结果不影响）。

引进一个新问题，如果从大到小开始遍历扫描，可能出现 **不连续的重复元素** 的 **不同顺序** 访问，得到不同的结果。

    提出解法：对于某个元素，我应当向左向右的贪心访问（若有重复元素邻接，则只贡献一次）。


时间复杂度：因为每个元素只会被访问一次：O(n)。

然而此解法实现复杂，五发（2h）才Accepted。

正解思路：非常简洁与干净，对于序列内的元素，统计峰值元素（中间严格大于两侧 -> 一定不能通过左右遍历得到，故贡献答案）

时间复杂度：O(n)


---

## 🚩 踩坑记录

- 重复连续元素作等效，大大降低复杂度。
- 多想想，时间 & 投入反而大大降低（Be lazy）

## 示例代码

见 [`solution.cpp`](./solution.cpp)
